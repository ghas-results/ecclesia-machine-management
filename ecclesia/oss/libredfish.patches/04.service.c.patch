--- src/service.c	2021-09-16 13:29:42.395550670 -0700
+++ src/service.c	2021-09-16 14:07:46.000000000 -0700
@@ -10,16 +10,17 @@
 #include <unistd.h>
 #endif
 
-#include "internal_service.h"
-#include "asyncEvent.h"
-#include <redfishService.h>
-#include <redfishPayload.h>
-#include <redpath.h>
-#include <redfishEvent.h>
-#include <redfishRawAsync.h>
-
-#include "debug.h"
-#include "util.h"
+
+
+#include "redfishService.h"
+#include "redfishPayload.h"
+#include "redpath.h"
+#include "redfishEvent.h"
+#include "redfishRawAsync.h"
+#include "asyncEvent.h"
+#include "asyncRaw.h"
+#include "debug.h"
+#include "util.h"
 
 /**
  * @brief A representation of event actor state.
@@ -35,15 +36,17 @@
 };
 
 /** Default asynchronous options for Redfish calls **/
-redfishAsyncOptions gDefaultOptions = {
+static const redfishAsyncOptions gDefaultOptions = {
     .accept = REDFISH_ACCEPT_JSON,
-    .timeout = 20
+    .timeout = 5L
 };
 
-static redfishService* createServiceEnumeratorNoAuth(const char* host, const char* rootUri, bool enumerate, unsigned int flags);
-static redfishService* createServiceEnumeratorBasicAuth(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags);
-static redfishService* createServiceEnumeratorSessionAuth(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags);
-static redfishService* createServiceEnumeratorToken(const char* host, const char* rootUri, const char* token, unsigned int flags);
+static void handleHostnameToRedfishService(const char* host, redfishService* service);
+static redfishService* createServiceEnumeratorNoAuth(const char* host, const char* rootUri, bool enumerate, unsigned int flags, const serviceHttpHandler* handler);
+static redfishService* createServiceEnumeratorBasicAuth(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, const serviceHttpHandler* handler);
+static redfishService* createServiceEnumeratorSessionAuth(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, const serviceHttpHandler* handler);
+static redfishService* createServiceEnumeratorToken(const char* host, const char* rootUri, const char* token, unsigned int flags, const serviceHttpHandler* handler);
+static redfishService* createServiceEnumeratorTlsAuth(const char* host, const char* rootUri, bool verifyPeer, bool verifyHostname, const char* clientCertFile, const char* clientKeyFile, const char* caCertFile, unsigned int flags, const serviceHttpHandler* handler);
 static char* makeUrlForService(redfishService* service, const char* uri);
 static json_t* getVersions(redfishService* service, const char* rootUri);
 static char* getSSEUri(redfishService* service);
@@ -51,31 +54,35 @@
 static void addStringToJsonObject(json_t* object, const char* key, const char* value);
 static redfishPayload* getPayloadFromAsyncResponse(asyncHttpResponse* response, redfishService* service);
 static unsigned char* base64_encode(const unsigned char* src, size_t len, size_t* out_len);
-static bool createServiceEnumeratorNoAuthAsync(const char* host, const char* rootUri, unsigned int flags, redfishCreateAsyncCallback callback, void* context);
-static bool createServiceEnumeratorBasicAuthAsync(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, redfishCreateAsyncCallback callback, void* context);
-static bool createServiceEnumeratorSessionAuthAsync(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, redfishCreateAsyncCallback callback, void* context);
-static bool createServiceEnumeratorTokenAsync(const char* host, const char* rootUri, const char* token, unsigned int flags, redfishCreateAsyncCallback callback, void* context);
+static bool createServiceEnumeratorNoAuthAsync(const char* host, const char* rootUri, unsigned int flags, redfishCreateAsyncCallback callback, void* context, const serviceHttpHandler* handler);
+static bool createServiceEnumeratorBasicAuthAsync(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, redfishCreateAsyncCallback callback, void* context, const serviceHttpHandler* handler);
+static bool createServiceEnumeratorSessionAuthAsync(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, redfishCreateAsyncCallback callback, void* context, const serviceHttpHandler* handler);
+static bool createServiceEnumeratorTokenAsync(const char* host, const char* rootUri, const char* token, unsigned int flags, redfishCreateAsyncCallback callback, void* context, const serviceHttpHandler* handler);
 static bool getVersionsAsync(redfishService* service, const char* rootUri, redfishCreateAsyncCallback callback, void* context);
 static char* getDestinationAddress(const char* addressInfo, SOCKET* socket);
 
-redfishService* createServiceEnumerator(const char* host, const char* rootUri, enumeratorAuthentication* auth, unsigned int flags)
+redfishService* createServiceEnumeratorExt(const char* host, const char* rootUri, enumeratorAuthentication* auth, unsigned int flags, const serviceHttpHandler* handler)
 {
-    REDFISH_DEBUG_DEBUG_PRINT("%s: Entered. host = %s, rootUri = %s, auth = %p, flags = %x\n", __func__, host, rootUri, auth, flags);
+    REDFISH_DEBUG_DEBUG_PRINT("%s: Entered. host = %s, rootUri = %s, auth = %p, flags = %x, handler = %p\n", __func__, host, rootUri, auth, flags, handler);
     if(auth == NULL)
     {
-        return createServiceEnumeratorNoAuth(host, rootUri, true, flags);
+        return createServiceEnumeratorNoAuth(host, rootUri, true, flags, handler);
     }
     if(auth->authType == REDFISH_AUTH_BASIC)
     {
-        return createServiceEnumeratorBasicAuth(host, rootUri, auth->authCodes.userPass.username, auth->authCodes.userPass.password, flags);
+        return createServiceEnumeratorBasicAuth(host, rootUri, auth->authCodes.userPass.username, auth->authCodes.userPass.password, flags, handler);
     }
     else if(auth->authType == REDFISH_AUTH_BEARER_TOKEN)
     {
-        return createServiceEnumeratorToken(host, rootUri, auth->authCodes.authToken.token, flags);
+        return createServiceEnumeratorToken(host, rootUri, auth->authCodes.authToken.token, flags, handler);
     }
     else if(auth->authType == REDFISH_AUTH_SESSION)
     {
-        return createServiceEnumeratorSessionAuth(host, rootUri, auth->authCodes.userPass.username, auth->authCodes.userPass.password, flags);
+        return createServiceEnumeratorSessionAuth(host, rootUri, auth->authCodes.userPass.username, auth->authCodes.userPass.password, flags, handler);
+    }
+    else if (auth->authType == REDFISH_AUTH_TLS)
+    {
+        return createServiceEnumeratorTlsAuth(host, rootUri, auth->authCodes.authTls.verifyPeer, auth->authCodes.authTls.verifyHostname, auth->authCodes.authTls.clientCertFile, auth->authCodes.authTls.clientKeyFile, auth->authCodes.authTls.caCertFile, flags, handler);
     }
     else
     {
@@ -83,6 +90,21 @@
     }
 }
 
+redfishService* createServiceEnumerator(const char* host, const char* rootUri, enumeratorAuthentication* auth, unsigned int flags)
+{
+    return createServiceEnumeratorExt(host, rootUri, auth, flags, NULL);
+}
+
+void updateServiceHost(redfishService* service, const char* host) {
+  mutex_lock(&service->endpoint_mutex);
+  char* old_host = service->host;
+  char* old_unix_domain_socket = service->unix_domain_socket;
+  handleHostnameToRedfishService(host, service);
+  free(old_host);
+  free(old_unix_domain_socket);
+  mutex_unlock(&service->endpoint_mutex);
+}
+
 /**
  * @brief An internal structure used to convert a call from async to sync.
  *
@@ -94,6 +116,8 @@
     mutex spinLock;
     /** The condition variable to be signalled on the async call completion **/
     condition waitForIt;
+    /** Number of threads still using this context **/
+    int refcount;
     /** The redfishPayload that was returned **/
     redfishPayload* data;
     /** True means the callback returned success, otherwise false **/
@@ -109,17 +133,33 @@
     {
         mutex_init(&context->spinLock);
         cond_init(&context->waitForIt);
+        context->refcount = 1;
         //We start out locked...
         mutex_lock(&context->spinLock);
     }
     return context;
 }
 
+/**
+ * Cleans up the asyncToSync context. The context lock must be held when
+ * entering this function. If the context is still being referenced elsewhere,
+ * this function will only decrement the refcount and release the lock. When
+ * no other references exist, the context's memory will be deleted.
+ */
 static void cleanupAsyncToSyncContext(asyncToSyncContext* context)
 {
-    mutex_destroy(&context->spinLock);
-    cond_destroy(&context->waitForIt);
-    free(context);
+    context->refcount--;
+    if (context->refcount == 0) {
+      if (context->data) {
+        cleanupPayload(context->data);
+      }
+      mutex_unlock(&context->spinLock);
+      mutex_destroy(&context->spinLock);
+      cond_destroy(&context->waitForIt);
+      free(context);
+    } else {
+      mutex_unlock(&context->spinLock);
+    }
 }
 
 static bool isOnAsyncThread(redfishService* service)
@@ -157,7 +197,79 @@
             free(content);
         }
     }
+    mutex_lock(&myContext->spinLock);
     cond_broadcast(&myContext->waitForIt);
+    cleanupAsyncToSyncContext(myContext);
+}
+
+// This method takes a JSON instance and a fragment and returns a pointer to
+// the property referenced by the fragment. JSON object ownership is managed
+// in this method; the json passed in is expected to be owned by the caller
+// and will be decref'd by this method. The JSON returned is expected to be
+// owned by the caller and will need to be decref'd in the future.
+json_t *googleJsonGetField(json_t *json, char *fragment) {
+  if (json == NULL || fragment == NULL) {
+    return NULL;
+  }
+  // Empty string, just return the provided json.
+  if (*fragment == '\0') return json;
+
+  // Note that this hack will work as long as our fragments only reference
+  // object and array types. Redfish Collections are currently not supported.
+  json_t *ret = NULL;
+  if (json_is_object(json)) {
+    ret = json_object_get(json, fragment);
+  } else if (json_is_array(json)) {
+    size_t index = strtoul(fragment, NULL, 10);
+    if (index < json_array_size(json)) {
+      ret = json_array_get(json, index);
+    }
+  }
+  if (ret != NULL) {
+    json_incref(ret);
+  }
+  json_decref(json);
+  return ret;
+}
+
+json_t *googleHandleJsonFragment(const char *uri, json_t *json) {
+  if (json == NULL) {
+    return json;
+  }
+
+  // Find the # character, which indicates that we have a fragment
+  char *fragment_start = strchr(uri, '#');
+  if (fragment_start == NULL || *(++fragment_start) == '\0') {
+    return json;
+  }
+
+  // Use an algorithm of incrementally replacing "/" characters with null
+  // terminators to split the fragment string and iteratively walk through the
+  // JSON property fields according to the fragment identifiers.
+  //
+  // This is similar to what strtok() would do, except strtok() is not
+  // threadsafe/reentrant so we cannot use strtok() here.
+  char *fragment_copy = strdup(fragment_start);
+  static const char delim = '/';
+  char *current_frag_ptr = fragment_copy;
+  char *delim_ptr = strchr(fragment_copy, delim);
+  while (delim_ptr != NULL && json != NULL) {
+    // Replace the delimeter with a null character
+    *delim_ptr = '\0';
+    // Current fragment is now a token (e.g. "AAA/BBB/CCC" is now "AAA").
+    // Fetch the object at that token.
+    json = googleJsonGetField(json, current_frag_ptr);
+    // Set the current_frag_ptr to look at the start of the next token.
+    current_frag_ptr = delim_ptr + 1;
+    delim_ptr = strchr(current_frag_ptr, delim);
+  }
+  // Catch the final fragment (e.g. "/AAA/BBB/CCC", this catches "CCC").
+  if (json != NULL) {
+    json = googleJsonGetField(json, current_frag_ptr);
+  }
+  free(fragment_copy);
+
+  return json;
 }
 
 json_t* getUriFromService(redfishService* service, const char* uri)
@@ -183,10 +295,12 @@
         REDFISH_DEBUG_CRIT_PRINT("%s: Failed to allocate context!\n", __func__);
         return NULL;
     }
+    context->refcount++;
     tmp = getUriFromServiceAsync(service,uri, NULL, asyncToSyncConverter, context);
     if(tmp == false)
     {
         REDFISH_DEBUG_ERR_PRINT("%s: Async call failed immediately...\n", __func__);
+        context->refcount--;
         cleanupAsyncToSyncContext(context);
         return NULL;
     }
@@ -195,7 +309,6 @@
     if(context->data)
     {
         json = json_incref(context->data->json);
-        cleanupPayload(context->data);
     }
     else
     {
@@ -203,6 +316,11 @@
     }
     cleanupAsyncToSyncContext(context);
     REDFISH_DEBUG_DEBUG_PRINT("%s: Exit. json = %p\n", __func__, json);
+
+    // GOOGLE: Hack in JSON fragment handling here. Replace the JSON we received
+    // from the server with the specific subfield requested by the URI fragment.
+    json = googleHandleJsonFragment(uri, json);
+
     return json;
 }
 
@@ -237,11 +355,13 @@
         cleanupAsyncToSyncContext(context);
         return false;
     }
+    context->refcount++;
     tmp = patchUriFromServiceAsync(service, uri, payload, NULL, asyncToSyncConverter, context);
     cleanupPayload(payload);
     if(tmp == false)
     {
         REDFISH_DEBUG_ERR_PRINT("%s: Async call failed immediately...\n", __func__);
+        context->refcount--;
         cleanupAsyncToSyncContext(context);
         return NULL;
     }
@@ -250,7 +370,6 @@
     if(context->data)
     {
         json = json_incref(context->data->json);
-        cleanupPayload(context->data);
     }
     else
     {
@@ -292,11 +411,13 @@
         cleanupAsyncToSyncContext(context);
         return NULL;
     }
+    context->refcount++;
     tmp = postUriFromServiceAsync(service, uri, payload, NULL, asyncToSyncConverter, context);
     cleanupPayload(payload);
     if(tmp == false)
     {
         REDFISH_DEBUG_ERR_PRINT("%s: Async call failed immediately...\n", __func__);
+        context->refcount--;
         cleanupAsyncToSyncContext(context);
         return NULL;
     }
@@ -305,7 +426,6 @@
     if(context->data)
     {
         json = json_incref(context->data->json);
-        cleanupPayload(context->data);
     }
     else
     {
@@ -347,10 +467,12 @@
         REDFISH_DEBUG_CRIT_PRINT("%s: Failed to allocate context!\n", __func__);
         return false;
     }
+    context->refcount++;
     tmp = deleteUriFromServiceAsync(service, uri, NULL, asyncToSyncConverter, context);
     if(tmp == false)
     {
         REDFISH_DEBUG_ERR_PRINT("%s: Async call failed immediately...\n", __func__);
+        context->refcount--;
         cleanupAsyncToSyncContext(context);
         return tmp;
     }
@@ -451,7 +573,7 @@
 
     if(options == NULL)
     {
-        options = &gDefaultOptions;
+        options = &service->default_async_options;
     }
     switch(options->accept)
     {
@@ -486,24 +608,24 @@
     request->timeout = options->timeout;
 }
 
-bool createServiceEnumeratorAsync(const char* host, const char* rootUri, enumeratorAuthentication* auth, unsigned int flags, redfishCreateAsyncCallback callback, void* context)
+bool createServiceEnumeratorAsyncExt(const char* host, const char* rootUri, enumeratorAuthentication* auth, unsigned int flags, redfishCreateAsyncCallback callback, void* context, const serviceHttpHandler* handler)
 {
-    REDFISH_DEBUG_DEBUG_PRINT("%s: Entered. host = %s, rootUri = %s, auth = %p, callback = %p, context = %p\n", __func__, host, rootUri, auth, callback, context);
+    REDFISH_DEBUG_DEBUG_PRINT("%s: Entered. host = %s, rootUri = %s, auth = %p, callback = %p, context = %p, handler = %p\n", __func__, host, rootUri, auth, callback, context, handler);
     if(auth == NULL)
     {
-        return createServiceEnumeratorNoAuthAsync(host, rootUri, flags, callback, context);
+        return createServiceEnumeratorNoAuthAsync(host, rootUri, flags, callback, context, handler);
     }
     if(auth->authType == REDFISH_AUTH_BASIC)
     {
-        return createServiceEnumeratorBasicAuthAsync(host, rootUri, auth->authCodes.userPass.username, auth->authCodes.userPass.password, flags, callback, context);
+        return createServiceEnumeratorBasicAuthAsync(host, rootUri, auth->authCodes.userPass.username, auth->authCodes.userPass.password, flags, callback, context, handler);
     }
     else if(auth->authType == REDFISH_AUTH_BEARER_TOKEN)
     {
-        return createServiceEnumeratorTokenAsync(host, rootUri, auth->authCodes.authToken.token, flags, callback, context);
+        return createServiceEnumeratorTokenAsync(host, rootUri, auth->authCodes.authToken.token, flags, callback, context, handler);
     }
     else if(auth->authType == REDFISH_AUTH_SESSION)
     {
-        return createServiceEnumeratorSessionAuthAsync(host, rootUri, auth->authCodes.userPass.username, auth->authCodes.userPass.password, flags, callback, context);
+        return createServiceEnumeratorSessionAuthAsync(host, rootUri, auth->authCodes.userPass.username, auth->authCodes.userPass.password, flags, callback, context, handler);
     }
     else
     {
@@ -511,6 +633,16 @@
     }
 }
 
+bool createServiceEnumeratorAsync(const char* host, const char* rootUri, enumeratorAuthentication* auth, unsigned int flags, redfishCreateAsyncCallback callback, void* context)
+{
+    return createServiceEnumeratorAsyncExt(host, rootUri, auth, flags, callback, context, NULL);
+}
+
+bool startRawAsyncRequest(redfishService* service, asyncHttpRequest* request, asyncRawCallback callback, void* callback_context)
+{
+  return service->start_request_handler(service, service->request_handler_context, request, callback, callback_context);
+}
+
 bool getUriFromServiceAsync(redfishService* service, const char* uri, redfishAsyncOptions* options, redfishAsyncCallback callback, void* context)
 {
     char* url;
@@ -963,12 +1095,14 @@
         cleanupPayload(postPayload);
         return false;
     }
+    asyncContext->refcount++;
     ret = postUriFromServiceAsync(service, eventSubscriptionUri, postPayload, NULL, asyncToSyncConverter, asyncContext);
     free(eventSubscriptionUri);
     cleanupPayload(postPayload);
     if(ret == false)
     {
         REDFISH_DEBUG_ERR_PRINT("%s: Async call failed immediately...\n", __func__);
+        asyncContext->refcount--;
         cleanupAsyncToSyncContext(asyncContext);
         return false;
     }
@@ -977,7 +1111,6 @@
     if(asyncContext->data)
     {
         service->eventRegistrationUri = getPayloadUri(asyncContext->data);
-        cleanupPayload(asyncContext->data);
     }
     if(asyncContext->success == false)
     {
@@ -1057,6 +1190,22 @@
     return ret;
 }
 
+redfishPayload* getPayloadByUri(redfishService* service, const char* uri)
+{
+    json_t* value;
+
+    if(!service || !uri)
+    {
+        return NULL;
+    }
+    value = getUriFromService(service, uri);
+    if(!value)
+    {
+        return NULL;
+    }
+    return createRedfishPayload(value, service);
+}
+
 void cleanupServiceEnumerator(redfishService* service)
 {
     if(!service)
@@ -1121,8 +1270,12 @@
         terminateAsyncEventThread(service);
     }
     terminateAsyncThread(service);
+    mutex_lock(&service->endpoint_mutex);
     free(service->host);
     service->host = NULL;
+    free(service->unix_domain_socket);
+    mutex_unlock(&service->endpoint_mutex);
+    mutex_destroy(&service->endpoint_mutex);
     json_decref(service->versions);
     service->versions = NULL;
     if(service->sessionToken != NULL)
@@ -1140,6 +1293,23 @@
         free(service->otherAuth);
         service->otherAuth = NULL;
     }
+    if (service->clientCertFile != NULL) {
+        free(service->clientCertFile);
+        service->clientCertFile = NULL;
+    }
+    if (service->clientKeyFile != NULL) {
+        free(service->clientKeyFile);
+        service->clientKeyFile = NULL;
+    }
+    if (service->caCertFile != NULL) {
+        free(service->caCertFile);
+        service->caCertFile = NULL;
+    }
+    if (service->cleanup_request_handler_context != NULL) {
+        // Call this even if request_handler_context is NULL:
+        // The user provided a cleanup, use it.
+        service->cleanup_request_handler_context(service->request_handler_context);
+    }
     if(service->selfTerm == false && service->eventTerm == false)
     {
         free(service);
@@ -1210,24 +1380,63 @@
     }
 }
 
-static redfishService* createServiceEnumeratorNoAuth(const char* host, const char* rootUri, bool enumerate, unsigned int flags)
+// Sets host unix_domain_socket on service. Does not manage the memory of either
+// member, so if those members are pointing to existing allocated memory, the
+// allocated memory must be freed prior to invoking this function. Assumes that
+// endpoint_mutex is held.
+static void handleHostnameToRedfishService(const char* host,
+                                           redfishService* service) {
+#ifdef _MSC_VER
+  service->host = _strdup(host);
+  service->unix_domain_socket = NULL;
+#else
+  // If the find the prefix "unix://", then host is a domain socket.
+  size_t host_len = strlen(host);
+  if (strlen(host) > 7 && strncmp("unix://", host, 7) == 0) {
+    size_t unix_domain_len = host_len - 7 + 1;
+    char *new_domain_socket = (char*)malloc(unix_domain_len);
+    memset(new_domain_socket, 0, unix_domain_len);
+    sprintf(new_domain_socket, "%s", host + 7);
+    // CURL needs some dummy hostname to create requests.
+    service->host = strdup("uds");
+    service->unix_domain_socket = new_domain_socket;
+  } else {
+    service->host = strdup(host);
+    service->unix_domain_socket = NULL;
+  }
+#endif
+}
+
+static redfishService* createServiceEnumeratorNoAuth(const char* host, const char* rootUri, bool enumerate, unsigned int flags, const serviceHttpHandler* handler)
 {
     redfishService* ret;
 
     ret = (redfishService*)calloc(1, sizeof(redfishService));
-	if(ret == NULL)
-	{
-		REDFISH_DEBUG_CRIT_PRINT("%s: Unable to allocate service!", __func__);
-		return NULL;
-	}
+    if(ret == NULL)
+    {
+        REDFISH_DEBUG_CRIT_PRINT("%s: Unable to allocate service!", __func__);
+        /* Handler is consumed even on failure. */
+        if (handler != NULL && handler->start_request_handler != NULL && handler->cleanup_request_handler_context != NULL) {
+            handler->cleanup_request_handler_context(handler->request_handler_context);
+        }
+        return NULL;
+    }
     serviceIncRef(ret);
-#ifdef _MSC_VER
-	ret->host = _strdup(host);
-#else
-    ret->host = strdup(host);
-#endif
+    mutex_init(&ret->endpoint_mutex);
+    mutex_lock(&ret->endpoint_mutex);
+    handleHostnameToRedfishService(host, ret);
+    mutex_unlock(&ret->endpoint_mutex);
     ret->flags = flags;
     ret->tcpSocket = -1;
+    if (handler != NULL && handler->start_request_handler != NULL) {
+        ret->start_request_handler = handler->start_request_handler;
+        ret->cleanup_request_handler_context = handler->cleanup_request_handler_context;
+        ret->request_handler_context = handler->request_handler_context;
+        ret->default_async_options = handler->default_async_options;
+    } else {
+        ret->start_request_handler = defaultStartRawAsyncRequest;
+        ret->default_async_options = gDefaultOptions;
+    }
     if(enumerate)
     {
         ret->versions = getVersions(ret, rootUri);
@@ -1236,7 +1445,7 @@
     return ret;
 }
 
-static bool createServiceEnumeratorNoAuthAsync(const char* host, const char* rootUri, unsigned int flags, redfishCreateAsyncCallback callback, void* context)
+static bool createServiceEnumeratorNoAuthAsync(const char* host, const char* rootUri, unsigned int flags, redfishCreateAsyncCallback callback, void* context, const serviceHttpHandler* handler)
 {
     redfishService* ret;
     bool rc;
@@ -1244,16 +1453,27 @@
     ret = (redfishService*)calloc(1, sizeof(redfishService));
     if(ret == NULL)
     {
+        if (handler != NULL && handler->start_request_handler != NULL && handler->cleanup_request_handler_context != NULL) {
+            handler->cleanup_request_handler_context(handler->request_handler_context);
+        }
         return false;
     }
     serviceIncRef(ret);
-#ifdef _MSC_VER
-    ret->host = _strdup(host);
-#else
-    ret->host = strdup(host);
-#endif
+    mutex_init(&ret->endpoint_mutex);
+    mutex_lock(&ret->endpoint_mutex);
+    handleHostnameToRedfishService(host, ret);
+    mutex_unlock(&ret->endpoint_mutex);
     ret->flags = flags;
     ret->tcpSocket = -1;
+    if (handler != NULL && handler->start_request_handler != NULL) {
+        ret->start_request_handler = handler->start_request_handler;
+        ret->cleanup_request_handler_context = handler->cleanup_request_handler_context;
+        ret->request_handler_context = handler->request_handler_context;
+        ret->default_async_options = handler->default_async_options;
+    } else {
+        ret->start_request_handler = defaultStartRawAsyncRequest;
+        ret->default_async_options = gDefaultOptions;
+    }
     rc = getVersionsAsync(ret, rootUri, callback, context);
     if(rc == false)
     {
@@ -1262,7 +1482,7 @@
     return rc;
 }
 
-static redfishService* createServiceEnumeratorBasicAuth(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags)
+static redfishService* createServiceEnumeratorBasicAuth(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, const serviceHttpHandler* handler)
 {
     redfishService* ret;
     char userPass[1024] = {0};
@@ -1279,13 +1499,13 @@
     snprintf(userPass, sizeof(userPass), "Basic %s", base64);
     free(base64);
 
-    ret = createServiceEnumeratorNoAuth(host, rootUri, false, flags);
+    ret = createServiceEnumeratorNoAuth(host, rootUri, false, flags, handler);
     ret->otherAuth = safeStrdup(userPass);
     ret->versions = getVersions(ret, rootUri);
     return ret;
 }
 
-static bool createServiceEnumeratorBasicAuthAsync(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, redfishCreateAsyncCallback callback, void* context)
+static bool createServiceEnumeratorBasicAuthAsync(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, redfishCreateAsyncCallback callback, void* context, const serviceHttpHandler* handler)
 {
     redfishService* ret;
     char userPass[1024] = {0};
@@ -1304,7 +1524,7 @@
     free(base64);
 
     //This does no network interactions when enumerate is false... use it because it's easier
-    ret = createServiceEnumeratorNoAuth(host, rootUri, false, flags);
+    ret = createServiceEnumeratorNoAuth(host, rootUri, false, flags, handler);
     if(ret == NULL)
     {
         return false;
@@ -1318,7 +1538,7 @@
     return rc;
 }
 
-static redfishService* createServiceEnumeratorSessionAuth(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags)
+static redfishService* createServiceEnumeratorSessionAuth(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, const serviceHttpHandler* handler)
 {
     redfishService* ret;
     redfishPayload* payload;
@@ -1330,7 +1550,7 @@
     json_t* post;
     char* content;
 
-    ret = createServiceEnumeratorNoAuth(host, rootUri, true, flags);
+    ret = createServiceEnumeratorNoAuth(host, rootUri, true, flags, handler);
     if(ret == NULL)
     {
         return NULL;
@@ -1389,6 +1609,19 @@
     return ret;
 }
 
+
+static redfishService* createServiceEnumeratorTlsAuth(const char* host, const char* rootUri, bool verifyPeer, bool verifyHostname, const char* clientCertFile, const char* clientKeyFile, const char* caCertFile, unsigned int flags, const serviceHttpHandler* handler)
+{
+    redfishService* ret = createServiceEnumeratorNoAuth(host, rootUri, false, flags, handler);
+    ret->verifyPeer = verifyPeer;
+    ret->verifyHostname = verifyHostname;
+    ret->clientCertFile = safeStrdup(clientCertFile);
+    ret->clientKeyFile = safeStrdup(clientKeyFile);
+    ret->caCertFile = safeStrdup(caCertFile);
+    ret->versions = getVersions(ret, rootUri);
+    return ret;
+}
+
 typedef struct {
     char* username;
     char* password;
@@ -1454,7 +1687,7 @@
         serviceDecRef(myContext->service);
         free(myContext);
         return;
-    } 
+    }
 #ifndef _MSC_VER
     //In order to be more useful and let callers actually cleanup things in their callback we're doing this on a seperate thread...
     pthread_attr_init(&attr);
@@ -1573,7 +1806,7 @@
     }
 }
 
-static bool createServiceEnumeratorSessionAuthAsync(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, redfishCreateAsyncCallback callback, void* context)
+static bool createServiceEnumeratorSessionAuthAsync(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, redfishCreateAsyncCallback callback, void* context, const serviceHttpHandler* handler)
 {
     bool rc;
     createServiceSessionAuthAsyncContext* myContext;
@@ -1590,7 +1823,7 @@
     myContext->originalContext = context;
     myContext->service = NULL;
 
-    rc = createServiceEnumeratorNoAuthAsync(host, rootUri, flags, finishedRedfishCreate, myContext);
+    rc = createServiceEnumeratorNoAuthAsync(host, rootUri, flags, finishedRedfishCreate, myContext, handler);
     if(rc == false)
     {
         free(myContext->username);
@@ -1600,11 +1833,11 @@
     return rc;
 }
 
-static redfishService* createServiceEnumeratorToken(const char* host, const char* rootUri, const char* token, unsigned int flags)
+static redfishService* createServiceEnumeratorToken(const char* host, const char* rootUri, const char* token, unsigned int flags, const serviceHttpHandler* handler)
 {
     redfishService* ret;
 
-    ret = createServiceEnumeratorNoAuth(host, rootUri, false, flags);
+    ret = createServiceEnumeratorNoAuth(host, rootUri, false, flags, handler);
     if(ret == NULL)
     {
         return ret;
@@ -1614,13 +1847,13 @@
     return ret;
 }
 
-static bool createServiceEnumeratorTokenAsync(const char* host, const char* rootUri, const char* token, unsigned int flags, redfishCreateAsyncCallback callback, void* context)
+static bool createServiceEnumeratorTokenAsync(const char* host, const char* rootUri, const char* token, unsigned int flags, redfishCreateAsyncCallback callback, void* context, const serviceHttpHandler* handler)
 {
     redfishService* ret;
     bool rc;
 
     //This does no network interactions when enumerate is false... use it because it's easier
-    ret = createServiceEnumeratorNoAuth(host, rootUri, false, flags);
+    ret = createServiceEnumeratorNoAuth(host, rootUri, false, flags, handler);
     if(ret == NULL)
     {
         return false;
@@ -1636,17 +1869,18 @@
 
 static char* makeUrlForService(redfishService* service, const char* uri)
 {
-    char* url;
+    char* url = NULL;
     size_t size;
+    mutex_lock(&service->endpoint_mutex);
     if(service->host == NULL)
     {
-        return NULL;
+        goto done;
     }
     size = strlen(service->host) + strlen(uri) + 1;
     url = (char*)malloc(size);
     if(url == NULL)
     {
-        return NULL;
+        goto done;
     }
 #ifdef _MSC_VER
     strcpy_s(url, size, service->host);
@@ -1655,6 +1889,8 @@
     strcpy(url, service->host);
     strcat(url, uri);
 #endif
+done:
+    mutex_unlock(&service->endpoint_mutex);
     return url;
 }
 
